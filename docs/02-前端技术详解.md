# 前端技术详解

## 1. Next.js 架构

### 1.1 框架版本与特性

本项目使用 **Next.js 15.1.4**，采用 App Router 架构模式。

**核心配置** (`next.config.ts`):
```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: 'standalone',        // 独立输出模式，适合Docker部署
  experimental: {
    serverActions: {
      bodySizeLimit: '50mb',   // 支持大文件上传
    },
  },
};
```

### 1.2 路由结构

```
src/app/
├── (dashboard)/              # 路由组 - Dashboard相关页面
│   ├── dashboard/
│   │   └── page.tsx          # /dashboard 主面板
│   └── layout.tsx            # Dashboard专用布局
├── api/                      # API Routes
│   ├── auth/
│   │   ├── login/route.ts    # POST /api/auth/login
│   │   ├── register/route.ts # POST /api/auth/register
│   │   ├── logout/route.ts   # POST /api/auth/logout
│   │   └── me/route.ts       # GET /api/auth/me
│   ├── upload/route.ts       # POST /api/upload
│   ├── excel/
│   │   ├── parse/route.ts    # POST /api/excel/parse
│   │   ├── simplify/route.ts # POST /api/excel/simplify
│   │   └── highlight/route.ts# POST /api/excel/highlight
│   └── report/route.ts       # POST /api/report
├── image-editor/
│   └── page.tsx              # /image-editor 图像编辑器
├── layout.tsx                # 根布局
├── page.tsx                  # / 首页(登录页)
└── globals.css               # 全局样式
```

### 1.3 布局系统

**根布局** (`src/app/layout.tsx`):
```typescript
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="zh-CN">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <Toaster />          {/* 全局Toast通知 */}
        {children}
      </body>
    </html>
  );
}
```

**Dashboard布局** (`src/app/(dashboard)/layout.tsx`):
```typescript
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen bg-gray-50">
      <Navbar />             {/* 顶部导航栏 */}
      <main className="container mx-auto px-4 py-8">
        {children}
      </main>
    </div>
  );
}
```

---

## 2. 组件架构

### 2.1 组件目录结构

```
src/components/
├── data-analysis/            # 数据分析功能组件
│   ├── analysis-results.tsx  # 分析结果展示
│   ├── chart-section.tsx     # 图表区域
│   ├── data-analysis-page.tsx# 数据分析页面主组件
│   ├── data-table.tsx        # 数据表格
│   ├── file-list.tsx         # 文件列表
│   ├── mutation-badge.tsx    # 突变类型标签
│   ├── report-dialog.tsx     # 报告生成对话框
│   └── stats-cards.tsx       # 统计卡片
├── image-editor/             # 图像编辑器组件
│   ├── canvas.tsx            # 画布组件
│   ├── editor.tsx            # 编辑器主组件
│   ├── toolbar.tsx           # 工具栏
│   └── layer-panel.tsx       # 图层面板
├── layout/                   # 布局组件
│   ├── navbar.tsx            # 导航栏
│   └── sidebar.tsx           # 侧边栏
├── ui/                       # 通用UI组件
│   ├── button.tsx            # 按钮
│   ├── card.tsx              # 卡片
│   ├── dialog.tsx            # 对话框
│   ├── dropdown-menu.tsx     # 下拉菜单
│   ├── input.tsx             # 输入框
│   ├── label.tsx             # 标签
│   ├── tabs.tsx              # 标签页
│   ├── toast.tsx             # Toast通知
│   └── toaster.tsx           # Toast容器
└── file-upload.tsx           # 文件上传组件
```

### 2.2 核心组件详解

#### 2.2.1 数据分析页面 (`DataAnalysisPage`)

**职责**: 整合数据分析的所有子组件，管理分析流程

```typescript
// src/components/data-analysis/data-analysis-page.tsx
export function DataAnalysisPage() {
  const { 
    files, 
    selectedFile, 
    analysisResult,
    isAnalyzing 
  } = useDataAnalysisStore();

  return (
    <div className="grid grid-cols-12 gap-6">
      {/* 左侧：文件列表 */}
      <div className="col-span-3">
        <FileList files={files} />
      </div>
      
      {/* 中间：数据展示 */}
      <div className="col-span-6">
        <DataTable data={selectedFile?.data} />
        <ChartSection data={analysisResult} />
      </div>
      
      {/* 右侧：分析结果 */}
      <div className="col-span-3">
        <StatsCards stats={analysisResult?.stats} />
        <AnalysisResults results={analysisResult} />
      </div>
    </div>
  );
}
```

#### 2.2.2 文件上传组件 (`FileUpload`)

**职责**: 处理Excel文件拖拽上传

```typescript
// src/components/file-upload.tsx
export function FileUpload({ onUpload }: FileUploadProps) {
  const [isDragging, setIsDragging] = useState(false);
  
  const handleDrop = async (e: DragEvent) => {
    e.preventDefault();
    const files = Array.from(e.dataTransfer.files);
    const excelFiles = files.filter(f => 
      f.name.endsWith('.xlsx') || f.name.endsWith('.xls')
    );
    
    for (const file of excelFiles) {
      await uploadFile(file);
    }
  };

  return (
    <div 
      className={cn(
        "border-2 border-dashed rounded-lg p-8 text-center",
        isDragging ? "border-blue-500 bg-blue-50" : "border-gray-300"
      )}
      onDrop={handleDrop}
      onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
      onDragLeave={() => setIsDragging(false)}
    >
      <Upload className="mx-auto h-12 w-12 text-gray-400" />
      <p>拖拽Excel文件到此处上传</p>
    </div>
  );
}
```

#### 2.2.3 报告生成对话框 (`ReportDialog`)

**职责**: 配置并触发AI报告生成

```typescript
// src/components/data-analysis/report-dialog.tsx
export function ReportDialog({ file, onClose }: ReportDialogProps) {
  const [reportType, setReportType] = useState<'docx' | 'pptx'>('docx');
  const [isGenerating, setIsGenerating] = useState(false);

  const handleGenerate = async () => {
    setIsGenerating(true);
    try {
      const response = await axios.post('/api/report', {
        fileId: file.id,
        type: reportType,
      });
      // 触发下载
      window.open(response.data.downloadUrl);
    } finally {
      setIsGenerating(false);
      onClose();
    }
  };

  return (
    <Dialog open onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>生成分析报告</DialogTitle>
        </DialogHeader>
        
        <Tabs value={reportType} onValueChange={setReportType}>
          <TabsList>
            <TabsTrigger value="docx">Word文档</TabsTrigger>
            <TabsTrigger value="pptx">PPT演示</TabsTrigger>
          </TabsList>
        </Tabs>
        
        <Button onClick={handleGenerate} disabled={isGenerating}>
          {isGenerating ? '生成中...' : '生成报告'}
        </Button>
      </DialogContent>
    </Dialog>
  );
}
```

### 2.3 UI组件库

项目使用 **Radix UI** 作为无样式组件基础，结合 **TailwindCSS** 进行样式定制。

**Button组件示例** (`src/components/ui/button.tsx`):
```typescript
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
```

---

## 3. 状态管理 (Zustand)

### 3.1 Store架构

```
src/store/
├── auth.ts                   # 用户认证状态
├── data-analysis-store.ts    # 数据分析状态
└── editor-store.ts           # 图像编辑器状态
```

### 3.2 认证状态 (`auth.ts`)

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: string;
  email: string;
  name: string;
}

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  
  // Actions
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  checkAuth: () => Promise<void>;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,

      login: async (email, password) => {
        const response = await axios.post('/api/auth/login', { email, password });
        set({
          user: response.data.user,
          token: response.data.token,
          isAuthenticated: true,
        });
      },

      logout: () => {
        set({ user: null, token: null, isAuthenticated: false });
      },

      checkAuth: async () => {
        try {
          const response = await axios.get('/api/auth/me');
          set({ user: response.data.user, isAuthenticated: true });
        } catch {
          set({ user: null, isAuthenticated: false });
        }
      },
    }),
    {
      name: 'auth-storage',  // localStorage key
    }
  )
);
```

### 3.3 数据分析状态 (`data-analysis-store.ts`)

```typescript
import { create } from 'zustand';

interface UploadedFile {
  id: string;
  name: string;
  path: string;
  uploadedAt: Date;
  data?: ExcelData;
}

interface AnalysisResult {
  stats: {
    totalSamples: number;
    mutationRate: number;
    editingEfficiency: number;
  };
  mutations: MutationType[];
  chartData: ChartDataPoint[];
}

interface DataAnalysisState {
  files: UploadedFile[];
  selectedFile: UploadedFile | null;
  analysisResult: AnalysisResult | null;
  isUploading: boolean;
  isAnalyzing: boolean;
  error: string | null;

  // Actions
  uploadFile: (file: File) => Promise<void>;
  selectFile: (fileId: string) => void;
  analyzeFile: (fileId: string) => Promise<void>;
  generateReport: (fileId: string, type: 'docx' | 'pptx') => Promise<string>;
  removeFile: (fileId: string) => void;
  clearError: () => void;
}

export const useDataAnalysisStore = create<DataAnalysisState>((set, get) => ({
  files: [],
  selectedFile: null,
  analysisResult: null,
  isUploading: false,
  isAnalyzing: false,
  error: null,

  uploadFile: async (file) => {
    set({ isUploading: true, error: null });
    try {
      const formData = new FormData();
      formData.append('file', file);
      
      const response = await axios.post('/api/upload', formData);
      
      set(state => ({
        files: [...state.files, response.data.file],
        isUploading: false,
      }));
    } catch (error) {
      set({ error: '文件上传失败', isUploading: false });
    }
  },

  selectFile: (fileId) => {
    const file = get().files.find(f => f.id === fileId);
    set({ selectedFile: file || null });
  },

  analyzeFile: async (fileId) => {
    set({ isAnalyzing: true, error: null });
    try {
      const response = await axios.post('/api/excel/parse', { fileId });
      set({ 
        analysisResult: response.data,
        isAnalyzing: false 
      });
    } catch (error) {
      set({ error: '分析失败', isAnalyzing: false });
    }
  },

  generateReport: async (fileId, type) => {
    const response = await axios.post('/api/report', { fileId, type });
    return response.data.downloadUrl;
  },

  removeFile: (fileId) => {
    set(state => ({
      files: state.files.filter(f => f.id !== fileId),
      selectedFile: state.selectedFile?.id === fileId ? null : state.selectedFile,
    }));
  },

  clearError: () => set({ error: null }),
}));
```

### 3.4 编辑器状态 (`editor-store.ts`)

```typescript
import { create } from 'zustand';

interface Layer {
  id: string;
  type: 'image' | 'text' | 'shape';
  x: number;
  y: number;
  width: number;
  height: number;
  rotation: number;
  opacity: number;
  visible: boolean;
  locked: boolean;
  data: Record<string, unknown>;
}

interface EditorState {
  layers: Layer[];
  selectedLayerId: string | null;
  tool: 'select' | 'draw' | 'text' | 'crop';
  zoom: number;
  history: Layer[][];
  historyIndex: number;

  // Actions
  addLayer: (layer: Omit<Layer, 'id'>) => void;
  updateLayer: (id: string, updates: Partial<Layer>) => void;
  deleteLayer: (id: string) => void;
  selectLayer: (id: string | null) => void;
  setTool: (tool: EditorState['tool']) => void;
  setZoom: (zoom: number) => void;
  undo: () => void;
  redo: () => void;
}

export const useEditorStore = create<EditorState>((set, get) => ({
  layers: [],
  selectedLayerId: null,
  tool: 'select',
  zoom: 1,
  history: [[]],
  historyIndex: 0,

  addLayer: (layer) => {
    const newLayer = { ...layer, id: crypto.randomUUID() };
    set(state => {
      const newLayers = [...state.layers, newLayer];
      return {
        layers: newLayers,
        history: [...state.history.slice(0, state.historyIndex + 1), newLayers],
        historyIndex: state.historyIndex + 1,
      };
    });
  },

  updateLayer: (id, updates) => {
    set(state => ({
      layers: state.layers.map(l => l.id === id ? { ...l, ...updates } : l),
    }));
  },

  deleteLayer: (id) => {
    set(state => ({
      layers: state.layers.filter(l => l.id !== id),
      selectedLayerId: state.selectedLayerId === id ? null : state.selectedLayerId,
    }));
  },

  selectLayer: (id) => set({ selectedLayerId: id }),
  setTool: (tool) => set({ tool }),
  setZoom: (zoom) => set({ zoom: Math.max(0.1, Math.min(5, zoom)) }),

  undo: () => {
    const { history, historyIndex } = get();
    if (historyIndex > 0) {
      set({
        layers: history[historyIndex - 1],
        historyIndex: historyIndex - 1,
      });
    }
  },

  redo: () => {
    const { history, historyIndex } = get();
    if (historyIndex < history.length - 1) {
      set({
        layers: history[historyIndex + 1],
        historyIndex: historyIndex + 1,
      });
    }
  },
}));
```

---

## 4. API 路由实现

### 4.1 认证API

**登录接口** (`src/app/api/auth/login/route.ts`):
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export async function POST(request: NextRequest) {
  try {
    const { email, password } = await request.json();

    // 查找用户
    const user = await prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      return NextResponse.json(
        { error: '用户不存在' },
        { status: 401 }
      );
    }

    // 验证密码
    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return NextResponse.json(
        { error: '密码错误' },
        { status: 401 }
      );
    }

    // 生成JWT
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET!,
      { expiresIn: '7d' }
    );

    // 创建会话
    await prisma.session.create({
      data: {
        userId: user.id,
        token,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      },
    });

    return NextResponse.json({
      user: { id: user.id, email: user.email, name: user.name },
      token,
    });
  } catch (error) {
    return NextResponse.json(
      { error: '登录失败' },
      { status: 500 }
    );
  }
}
```

### 4.2 文件上传API

**上传接口** (`src/app/api/upload/route.ts`):
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { prisma } from '@/lib/prisma';
import { getUser } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const user = await getUser(request);
    if (!user) {
      return NextResponse.json({ error: '未授权' }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json({ error: '未提供文件' }, { status: 400 });
    }

    // 生成唯一文件名
    const fileId = uuidv4();
    const ext = path.extname(file.name);
    const fileName = `${fileId}${ext}`;
    
    // 确保用户目录存在
    const userDir = path.join(process.cwd(), 'uploads', user.id);
    await mkdir(userDir, { recursive: true });
    
    // 保存文件
    const filePath = path.join(userDir, fileName);
    const bytes = await file.arrayBuffer();
    await writeFile(filePath, Buffer.from(bytes));

    // 记录到数据库
    const uploadedFile = await prisma.uploadedFile.create({
      data: {
        id: fileId,
        name: file.name,
        path: filePath,
        userId: user.id,
        size: file.size,
        mimeType: file.type,
      },
    });

    return NextResponse.json({ file: uploadedFile });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json({ error: '上传失败' }, { status: 500 });
  }
}
```

### 4.3 报告生成API

**报告接口** (`src/app/api/report/route.ts`):
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getUser } from '@/lib/auth';

const PYTHON_SERVICE_URL = process.env.PYTHON_SERVICE_URL || 'http://localhost:8000';

export async function POST(request: NextRequest) {
  try {
    const user = await getUser(request);
    if (!user) {
      return NextResponse.json({ error: '未授权' }, { status: 401 });
    }

    const { fileId, type } = await request.json();

    // 调用Python服务生成报告
    const response = await fetch(`${PYTHON_SERVICE_URL}/generate-report`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        file_id: fileId,
        report_type: type,
        user_id: user.id,
      }),
    });

    if (!response.ok) {
      throw new Error('Python服务错误');
    }

    const result = await response.json();
    
    return NextResponse.json({
      success: true,
      reportPath: result.report_path,
      downloadUrl: `/api/download?file=${encodeURIComponent(result.report_path)}`,
    });
  } catch (error) {
    console.error('Report generation error:', error);
    return NextResponse.json({ error: '报告生成失败' }, { status: 500 });
  }
}
```

---

## 5. 样式系统

### 5.1 TailwindCSS配置

**全局样式** (`src/app/globals.css`):
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
```

### 5.2 工具函数

**cn函数** (`src/lib/utils.ts`):
```typescript
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

---

## 6. 中间件

### 6.1 认证中间件

**路由保护** (`src/middleware.ts`):
```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// 需要认证的路由
const protectedRoutes = ['/dashboard', '/image-editor'];
// 公开路由
const publicRoutes = ['/', '/api/auth/login', '/api/auth/register'];

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // 检查是否是受保护的路由
  const isProtectedRoute = protectedRoutes.some(route => 
    pathname.startsWith(route)
  );
  
  if (isProtectedRoute) {
    // 检查认证状态
    const token = request.cookies.get('auth-token')?.value;
    
    if (!token) {
      // 重定向到登录页
      return NextResponse.redirect(new URL('/', request.url));
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
};
```

---

## 7. 相关文档

| 文档 | 描述 |
|------|------|
| [01-项目概述与架构](./01-项目概述与架构.md) | 项目整体架构与技术栈 |
| [03-后端服务详解](./03-后端服务详解.md) | Python后端服务实现 |
| [04-数据库设计](./04-数据库设计.md) | 数据模型与Prisma配置 |

---

*文档版本: 1.0.0 | 更新时间: 2026-02-10*
